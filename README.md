# ИНФОМАРЦИЯ О КАЛЬКУЛЯТОРЕ

Я - OnePailas. Написал на языке Python калькулятор с графическим интерфейсом, содержащий арифметические действия над цифрами. 

Цель написания данного калькулятора: изучение библиотеки Tkinter, чтобы иметь возможность создавать программы с графическим интерфейсом. \
Данный калькулятор полезности в себе не несет, кроме написанного кода, который может быть служить примером для выполнения задачи с похожим запросом пользователя GitHub.

## Tkinter и параметр "ttk"

Для достежения моей цели была применена библиотека Tkinter, которая дает возможность создавать и компоновать в одно целое из таких элементов, как: Кнопка(`Button`), Поле Ввода(`Entry`), Текст(`Label`), Стиль(`Style`) и тд.
___

### Кнопка. Button()

Для создания кнопок и их расположения, я применял параметр "`ttk`". С помощью которого предавал кнопкам более приятный внешний вид. \
Позиционировал и с помощью метода "`.place()`", задавая размеры и расположение в окне. \
В параметрах кнопки задавал отображаемый текст и исполняемую фунцию через переменную "`command = `". Пример кода создания кнопки:

```python
from tkinter import *
from tkinter import ttk, Tk

tk = Tk()
tk.title('Calcutor py')
tk.geometry('400x600+720+200')
tk.resizable(False, False)

tk.iconbitmap('calc.ico')

button = ttk.Button(text = '+/-', command = pl_and_mn)
button.place(x = 0, y = 525, width = 100, height = 75)

tk.mainloop()
```
В данном коде импортировалась бибилиотека, создавалось окно, задавалось название, икнока, размеры, без разрешения на изменения. Дальше идет переменная `Button`, которая хранит элемент кнопки и ее параметры, а далее позиционирование `.place()` с размерами кнопки и расположением относительно координатам окна.
___

### Поле ввода. Entry()

Для ввода значений применялся элемент Entry, который имел параметры текста - `text =`, шрифта и его размеры - `font = ()`, и выравнивание текста исходя из его значения `justify = `


```python
def active_entry(entry_widget):
    entry_widget.focus_set()

entry = ttk.Entry(text = '', font = ('Arial', 20), justify = RIGHT)
entry.pack(anchor = W, fill = X, ipady = 42)
active_entry(entry)
```

Позиционировалась она с помощью метода `.pack()`, который позволял распологать поле ввода и задавать размеры относительно окна. \
Также, чтобы при запуске калькулятора сразу вводить в поле ввода символы, выполнялась функция фокусировки на поле ввода с помощью функции `active_entry`, которая содержит в себе параметр `entry_widget` для взаимодействия с полем ввода. Дальше обращение к полю и фокусируем его. 
___

### Арифметические функции

Далее идет арифметика. Помимо базовой арифметики, я решил добавить функцию находжения корня, возведения чилса в требуеюмую степень, и 1 деленное на требуемое число. В пример пояснения возьму функцию умножения. 

```python
def btn_multipy():
    en = str(entry.get())
    if en == '' or en.count('*') >= 1 or en == '1 / ' or en == ' - ' or en == '0.':
        entry.insert(END, '')
    else:
        entry.insert(END, ' * ')

button_multiply = ttk.Button(text = '*', command = btn_multipy)
button_multiply.place(x = 300, y = 300, width = 100, height = 75)
```

Первым делом проверяю поле ввода на наличие символов, чтобы нельзя было поставить знак умножения перед числом, так как это вызывает ошибку. Далее добавляю условию того, что знак будет не больше 1. Также ввожу проверки поле ввода на наличе различных ариметических действий, чтобы нельзя было писать подряд многие знаки подсчетов(Данная проверка "различных действий" стоит во многих функций подсчета, чтобы минимизировать количество ошибок) Если условие не удовлетворено, то знак плюса не будет вписан в поле. В иных случаях знак будет добавляться. Так аналогично работают остальные функции арифметики в данном калькуляторе, изучить можете в исходном коде. \
А теперь мы создаем переменную и помещаем элемент Кнопки с требуемым текстом и с требуемой функцией через переменную `command =`. Для позиционирования кнопки в окне через координаты и изменение размеров задаем через метод `.place()`.

    Сложение - `def btn_plus()`
    Вычитание - `def btn_minus()`
    Умножение - `def btn_multipy()`
    Деление - `def div()`
    1 деленный на x - `def one_and_x()`
    X в степени x - `def x_stepen()`
    Корень квадратный из x - `def koren()`
___

### Ввод чисел. def

Когда мне предстояло уже вводить числа в поле ввода через клавиатуру, то открылось то, что у меня почему-то события для обработки нажатий клавиш не работают. Поэтому, чтобы не останавливаться, я решил придумать абстрактный метод ввода символ с клавиш в поле ввода.

```python
def null():
    if str(entry.get()) == '1 / ':
        entry.insert(END, '')
    else:
        entry.insert(END, '0')

def button_1(): 
    entry.insert(END, '1')
    en = str(entry.get())
    if en[0] == '0' and en[1] != '.':
        entry.delete(0, END)
        entry.insert(END, '1')

button0 = ttk.Button(text = '0', command = null)
button0.place(x = 100, y = 525, width = 100, height = 75)

button1 = ttk.Button(text = '1', command = button_1)
button1.place(x = 0, y = 450, width = 100, height = 75)
```

Для примера будет служить 0 и 1. Для нуля я вводил проверку на наличие в поле ввода арифметического действия "1 / x", надо, чтобы пользователь не мог в знаменатель ввести 0, так как данная дробь неверна и вызывает ошибку. Если ничего нет, то пользователь вводи ноль в поле и работает с ним дальше.
Теперь идет 1. В поле сразу вводится цифра, но если в содержимом Entry есть ноль, но нет точки, то поле ввода очищается и вводится цифра 1. К чему данная проверка? Если -25 + 25 = 0, то ответ вводится в поле ввода, но вот если вы захотим ввести другие цифры и произвести арифметическое действие, то снова будет ошибка и никакой ответ калькулятор вывести не сможет, так как 0123 + 123 = ошибка.
Точка нужна была, чтобы избавиться от лишнего нуля, но не потерять возможность вводить булевые числа(десятичная дробь: 0.5; 0.25 и раличные). Ведь если проверки на точки не будет и мы захотим ввести например "0.1", то любая введенная цифра удалит содержимое, то есть данное действие будет повторяться, без доступа к вводу булевых значений. 

```python
def btn_res():
    result = eval(entry.get())
    print(result)
    entry.delete(0, END)
    entry.insert(0, result)

button_result = ttk.Button(text = '=', command = btn_res)
button_result.place(x = 300, y = 525, width = 100, height = 75)
```

Нахождение ответа тоже не мало важная часть. Снова через функцию мы будет с ней взаимодействовать. Сначало в переменную `result =` мы помещаем функцию `eval()`, а внутрь содержимое поле ввода. `eval()` нам нужен для быстрого подсчета, так как данная функция умеет работать с разными арифметическими знаками(прибалять, делить, умножать и так далее). Если мы не применяли ее, то только получение содержимого добавило бы много работ. Теперь очищаем поле ввода и вводим полученный ответ. `print(result)` пишем по желанию, мне вывод требовался для понимания того, что функция работает правильно.  
___

### Стиль. Style()

Теперь обращаем внимание на то, что все это время шрифт кнопок был маленьким и не читаемым. Исправляем это с помощью конфигурации элемента `.Style()`: 

```python
ttk.Style().configure('.', font = ('Arial', 16), foreground = 'black')
```

Здесь мы получаем доступ к конфигурации элемента `.Style()`.
Чтобы задать стиль, то есть в нашем случае шрифт всем элементам, нужно написать `'.'`, после этого в переменную `font=()` мы помещаем наш шрифт и его размер. Цвет шрифта можно изменить с помощью переменной `foreground=`, задаем требуемый цвет, либо через решетку(#) можно указать код цвета. Например `foreground = '#123456'`, так можно указать любой другой цвет. 
___

## Вердикт

Вердикт таков: \
Калькулятор был неким эксперементом для меня. Это было изучение, это была практика библиотеки на примере создания калькулятора. Считаю, что цель была выполнена и это дает мне хорошую почву, чтобы создавать другие программы, применяя другие инструменты для достижения своих целей, которые могут оказаться даже сложнее. Даже когда я попал в патовую ситуацию, где я не понимал, как мне начать взаимодействовать с кнопками, полем ввода, я все же нашел решение. Да, оно очень абстрактное и странное, но самое главное, что это работает и позволяет выполнять функции калькулятора. \
В этом калькуляторе может и есть некоторые минусы, а то и дыры, которые вы нашли, а я нет. Но данный калькулятор был написан чисто полученными моими знаниями, не примення уже готовые решения различных создателей. Хоть он и не реагирует на нажатия на клавиш, как хотелось бы, но я не думаю, что это минус, а наоборот - этот "минус" дал мне толчок широких мыслей и решений, которые были применены для приближения к завершению задачи. 

*Благодарю вас за внимание. OnePailas.*
